



















public void update(float delta, WorldViewport viewport, float sunIntensity) {
		clearLightMaps(viewport);

		renderSunlight(viewport, sunIntensity);

		for (Light light : lights) {
			if (lightVisible(light, viewport)) {
				renderLight(light, viewport);
			}
		}
	}

	private boolean lightVisible(Light light, WorldViewport viewport) {
		float x = light.getX() * PhysicsManager.PPM;
		float y = light.getY() * PhysicsManager.PPM;
		float dist = light.getDistance() * PhysicsManager.PPM;

		tmpRect.set(x - dist, y - dist, dist * 2, dist * 2);

		return viewport.contains(tmpRect);
	}

	private void renderLight(Light light, WorldViewport viewport) {
		float x = light.getX();
		float y = light.getY();
		float dist = light.getDistance();

		float step = 1 / (float) (resolution);
		for (float x0 = x - dist; x0 < x + dist; x0 += step) {
			for (float y0 = y - dist; y0 < y + dist; y0 += step) {
				if (x >= 0 && x < world.getWidth()) {
					if (y >= 0 && y < world.getHeight()) {
						float xk = x - x0;
						float yk = y - y0;
						float dist0 = (float) Math.sqrt(Math.abs(xk * xk + yk * yk));
						float intensity = (dist - Math.max(dist0, 0.01f)) / dist;

						if (intensity > 0.03f) {
							addLightValue(x0, y0, RGBAHelper.applyIntensity(light.getColor(), intensity));
						}
					}
				}
			}
		}
	}

	private void renderSunlight(WorldViewport viewport, float sunIntensity) {
		if (sunIntensity <= 0.0f) {
			return;
		}

		float x0 = viewport.getX();
		float y0 = viewport.getY();
		float x1 = x0 + viewport.getWidth();
		float y1 = y0 + viewport.getHeight();
		int x01 = (int) (x0 / Tile.TILE_SIZE) - 2;
		int y01 = (int) (y0 / Tile.TILE_SIZE) - 2;
		int x11 = (int) (x1 / Tile.TILE_SIZE) + 2;
		int y11 = (int) (y1 / Tile.TILE_SIZE) + 2;

		final float sunDist = 3;

		float step = 1 / (float) (resolution);
		for (float x = x01; x <= x11; x += step) {
			if (x >= 0 && x < world.getWidth()) {
				float heightVal = world.getHighestTileAt((int) x);

				// if we have higher resolution then we interpolate with the
				// height values of the neighbor
				if (resolution > 1) {
					float dif = x - (int) (x);
					int delta = dif >= 0.5 ? 1 : -1;

					int neighborTileX = (int) (x) + delta;
					float neighborHeightVal = world.getHighestTileAt(neighborTileX);
					float heightDif = neighborHeightVal - heightVal;

					float amount = Math.abs(dif - 0.5f);

					heightVal += heightDif * amount;
				}

				for (float y = y11; y >= y01; y -= step) {
					float dif = (heightVal - y);

					float intensity = 1f;
					if (dif >= 0) {
						intensity = (sunDist - dif) / sunDist;
					}

					if (intensity > 0.03f) {
						addLightValue(x, y, RGBAHelper.applyIntensity(0xFFFFFFFF, sunIntensity * intensity));
					}
				}
			}
		}
	}

	private int getLightValue(float x, float y) {
		int chunkX = (int) (x) / WorldChunk.CHUNK_SIZE;
		int chunkY = (int) (y) / WorldChunk.CHUNK_SIZE;

		LightMap lightMap = getLightMap(chunkX, chunkY);
		if (lightMap != null) {
			int xLightMap = (int) ((x - (chunkX * WorldChunk.CHUNK_SIZE)) * resolution);
			int yLightMap = (int) ((y - (chunkY * WorldChunk.CHUNK_SIZE)) * resolution);

			return lightMap.getLightColor(xLightMap, yLightMap);
		}

		return 0x00;
	}

	private void addLightValue(float x, float y, int color) {
		int r = RGBAHelper.mix(color, getLightValue(x, y));

		setLightValue(x, y, r);
	}

	private void setLightValue(float x, float y, int color) {
		int chunkX = (int) (x) / WorldChunk.CHUNK_SIZE;
		int chunkY = (int) (y) / WorldChunk.CHUNK_SIZE;

		LightMap lightMap = getLightMap(chunkX, chunkY);
		if (lightMap != null) {
			int xLightMap = (int) ((x - (chunkX * WorldChunk.CHUNK_SIZE)) * resolution);
			int yLightMap = (int) ((y - (chunkY * WorldChunk.CHUNK_SIZE)) * resolution);

			lightMap.setLightColor(xLightMap, yLightMap, color);
		}
	}